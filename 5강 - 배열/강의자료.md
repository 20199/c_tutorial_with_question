# 배열

## 목차

[1. 서론](#서론)

[2. 1차원 배열](#1차원-배열)

[3. 다차원 배열](#다차원-배열)

[4. 배열의 크기 구하기](#배열의-크기-구하기)

[5. 배열과 함수](#배열과-함수)

[6. 배열을 포인터에 넣기](배열을-포인터에-넣기)

[7. 문자열](#문자열)

[8. 문자열에서 자주 쓰이는 함수](#문자열에서-자주-쓰이는-함수)



## 서론

 10명의 학생이 있는데, 성적의 평균을 구한다고 합시다. 10명의 성적을 모두 더한 후 나누면 되겠죠? 

하지만 10명이 아니라 100명, 1000명이면 어떨까요? 일일이 변수를 만들어 더할 수는 없습니다.

위와 같이 같은 형의 많은 데이터를 처리하고자 할 때는 배열이 유용합니다. 같은 자료형의 변수를 일렬로 늫어놓고 보통 반복문과 함께 사용해 반복되는 값을 손쉽게 처리할 수 있습니다.



## 1차원 배열 

1차원 배열을 선언해봅시다.

형 배열이름[배열크기]

`int grade[10];

그러면 메모리에 int형 변수가 연속된 공간에 10개 할당되고 각각의 이름은 grade[0], grade[1] ... grade[10]

조심해야할 것은 배열에서 인덱스는 0부터 시작한다는 것입니다.



배열은 선언과 동시에 초기화할 수도 있습니다.

`int grade[5] = { 70, 77, 41 98, 60};

또한 이 경우에는 배열 크기를 생략할 수도 있습니다.

`int grade = { 70, 77, 41 98, 60};



 이번에는 10명의 학생의 성적을 받아서 평균을 내는 예제를 살펴봅시다.

**예제 추가 예정**프로그램5.1



그런데 학생 수가 100명으로 늘었다고 합니다. 그렇다면 프로그램 내 모든 10을 100으로 바꿔야겠죠. 예제처럼 작은 프로그램은 바꾸기 쉽겠지만 규모가 매우 큰 프로그램이라면 어떻게 할까요?



**기호상수** #define을 이용합니다.



**바꾼 예제 추가 예정**프로그램5.2



## 다차원 배열



위처럼 grade[5]와 같은 배열을 1차원 배열이라고 합니다. 하지만 배열을 꼭 1차원으로만 쓰는것은 아닙니다.



2차원 배열을 살펴봅시다.

`int a[3][4\] ;

2차원 배열은 직사각형 모양을 생각하면 됩니다.

|  a   |   [0]    |   [1]    |   [2]    |
| :--: | :------: | :------: | :------: |
| a[0] | a[0][0\] | a[0][1\] | a[0][2\] |
| a[1] | a[1][0\] | a[1][1\] | a[1][2\] |
| a[2] | a[2][0\] | a[2][1\] | a[2][2\] |
| a[3] | a[3][0\] | a[3][1\] | a[3][2\] |



예제를 살펴봅시다.

**프로그램 5.3**

```
#define N 3   // 학생 수
#define M 4   // 과목 수
int main(void){
  int grades[N][M], student[N] = {0}, i, j;
   for (i = 0; i < N; ++i)
     for (j = 0; j < M; ++j)
        scanf("%d", &grades[i][j]);
   for (i = 0; i < N; ++i){
     for (j = 0; j < M; ++j)
        student[i] += grades[i][j];
     printf(“%1d 평균 : %5.2f\n", i, (float)student[i] / M);
   }
}
```



다차원 배열을 초기화할 때는 중괄호를 사용하면 편합니다.

```
int b[2][3] = {1, 2, 3, 4, 5, 6};
int b[2][3] = {{1, 2, 3}, {4, 5, 6}};
int b[ ][3] = {{1, 2, 3}, {4, 5, 6}};
```



## 배열의 크기  구하기



작업을 하다보면 배열의 크기를 바꾸고, 반복문을 더하고 하는 도중 오류가 발생하게 됩니다.

이런 오류를 최소화하기 위해 배열의 크기를 알아내는 법을 알아봅시다.

`int num[10];

int형 변수 10개가 있는 배열이 있습니다. sizeof 연산자를 활용해 봅시다

```
printf("%d\n", sizeof(numArr));  
```

**출력 결과** 40



왜 40일까요? 바로 int형 요소가 4바이트를 차지하기 때문입니다.

따라서 int형 배열의 크기를 구하려면 다음과 같이 하면 됩니다.

```
printf("%d\n", sizeof(num) / sizeof(int));
```



배열을 사용할때 오류는 보통 인덱스가 배열의 범위를 벗어난 경우에 생깁니다. 따라서 작업을 할 때 항상 이 부분을 생각하면서 작성해야 합니다.

```
int num[10];  
int index = 10;
int count = sizeof(num) / sizeof(int);

if (index <= count - 1){
  ...
}
```



count - 1은 9이고, index가 9를 넘었다는건(10이상) num[10]의 인덱스를 초과했다는 것이 됩니다.

여기서도 배열 인덱스의 시작이 0이라는 것에 주의해야 합니다.



## 배열과 함수



함수 헤더에서 매개변수로 1차원 배열을 쓸 때, 배열의 크기는 생략이 가능합니다.

성적의 합을 구하는 sum함수 헤더에서

```
int sum(int grade[4], int size);
int sum(int grade[], int size);
```

두 헤더가 같은 의미라는 말입니다.



두 번째 방식의 장점은 함수가 **임의의 크기 배열**을 다룰 수 있다는 것입니다.

size인자로 배열 크기를 받습니다.



예제를 살펴봅시다.

**프로그램 5.4** 추가 예정

```

```



## 배열을 포인터에 넣기

배열은 사실 첫 번째 요소의 주솟값입니다.

예를 들어 int num[10];이 있을때

num은 num[0];의 주솟값입니다.

이를 이용해 포인터에 배열을 넣은 후 포인터에서 배열 요소에 접근할 수 있습니다.

**프로그램 5.5**

```
#include <stdio.h>

int main(){

  int num[5] = { 1, 2, 3, 4, 5};
  int *numPtr = num;     
  
  printf("%d\n", *numPtr);   
  printf("%d\n", *num);   
  printf("%d\n", numPtr[4]);  
  printf("%d\n", sizeof(num));
                                       

  return 0;
}
```

**실행 결과**

1

1

5

20



## 문자열

문자열은 char형의 1차원 배열입니다.

문자열의 끝을 구분하기 위해, 문자열은 \0(널 문자)로 끝이 납니다.

**프로그램 7.6**

```
#include <stdio.h>

int main(){

  char ch1 = 'a';
  char *ch2 = "a";
  char *s1 = "Hello"
  
  printf("%c\n", ch1);
  printf("%s\n", ch2);
  printf("%s\n", s1);
  
  return 0;
  
}

```

**실행 결과**

a

a

Hello



만약 문자열의 선언을 char s1 = "Hello"; 로 했다면 올바른 선언일까요?

아닙니다. 문자열은 변수에 직접 저장하지 않고 포인터를 이용해 저장합니다.

포인터를 이용해 문자열이 저장된 메모리 주소를 찾아가는 것이어서 s1은 Hello\n 가 저장되어 있는 메모리의 주소를 가리키는 것입니다.



또, 예제에서 'a'와 "a"는 엄연히 다릅니다.

문자열은 항상 \n으로 끝나기 때문에,

'a'는 하나의 원소

"a"는 'a'와 '\n' 두 원소로 이루어진 문자열입니다.



## 문자열에서 자주 쓰이는 함수  
추가예정



