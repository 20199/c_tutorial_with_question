# 포인터

## 목차
[1. 포인터](#포인터)   
[2. 연산자](#&-연산자)   
[3. 포인터와 함수](#포인터와-함수)   
[4. 배열과 포인터](#배열과-포인터)   
[5. 포인터 배열](#포인터-배열)   
[6. 문자열과 포인터](#문자열과-포인터)   
[7. 동적 메모리 할당](#동적-메모리-할당)   



## 주소
선언한 변수들의 데이터는 메모리에 저장됩니다.  
컴퓨터는 데이터를 불러오기 위해 메모리의 위치가 필요한데 이를 주소라고 합니다.

## 포인터
* 주소를 다루기 위한 자료형
* 메모리 상에 위치한 데이터의 주소값을 저장하는 변수

> 포인터 변수 선언 방법
```c
int *p;         // int형 포인터 변수 p를 선언합니다.
int *a, b;      // int형 포인터 변수 a 와 int형 변수 b를 선언합니다.
int *a, *b;     // int형 포인터 변수 a 와 b 를 선언합니다.
```


## & 연산자
메모리의 주소를 알려주는 연산자

> & 연산자 예
```c 
int i ;
printf("%d", &i);
```

## * 연산자
포인터 가리키는 메모리의 공간에 접근하는 연산자

> * 연산자 예
```c 
int i ;
int *p = &i;
printf("%d", *p);
```


## 포인터 변수의 크기
* 자료형과 관계없이 8바이트로 크기가 동일합니다.

## 포인터와 함수
포인터가 필요한 이유    
- C 프로그램에서 함수에 변수를 넘기면 기본적으로 변수 자체가 아닌 값만 복사해서 넘겨줍니다. (값에 의한 호출)

- 함수에서 변수의 값이 바뀌어 저장할 필요가 있을 때 포인터를 통해 넘겨줄 수 있습니다. (참조에 의한 호출)

- 반환 값이 여러 개인 경우에도 참조에 의한 호출로 해결할 수 있습니다.

## 값에 의한 호출

```c
void swap(int a, int b);
int main()
{
    int a = 1, b = 2;
    swap(a,b);
    printf("main - a : %d  b : %d", a,b);
    return 0;
}

void swap(int a, int b)
{
    int temp;

    temp = a;
    a = b;
    b = temp;

    printf("swap -  a : %d  b : %d ", a,b);
}
```
---
**프로그램 결과**

    swap - a : 2   b : 1 
    main - a : 1   b : 2 
    
    // 값이 바뀌지 않았습니다.
---

함수 안에서 변수를 서로 교환했지만 함수 내에서만 바뀌었는데 main 함수에서 
swap 함수로 넘겨줄때 값만 넘겨준 것을 볼 수 있습니다.


## 참조에 의한 호출

* 참조에 의한 호출 방법  

```c
void swap(int * a, int * b);            // 매개 변수를 포인터 형으로 선언합니다.
int main()
{
    int a = 1, b = 2;
    swap(&a,&b);                        // 함수의 주소를 인자로 전달합니다.
    printf("main - a : %d  b : %d", a,b);
    return 0;
}

void swap(int *a, int *b)
{
    int temp;

    temp = *a;                          // * 연산자를 이용해 값을 사용합니다.
    *a = *b;
    *b = temp;

    printf("swap -  a : %d  b : %d ", a,b);
}
```
---
**프로그램 결과**

    swap - a : 2   b : 1 
    main - a : 2   b : 1 
    
    // swap 함수 밖에서도 바뀐 것을 확인 할 수 있습니다.
---

## 배열과 포인터
배열은 단순히 자료형을 여러개 저장하는 것이 아니라 메모리 상에서 연속해서 저장한 형태입니다.

이와 같은 특성 때문에 포인터 연산을 이용해 배열을 다룰 수 있습니다.

* 배열 이름으로 참조 연산을 하면 배열의 첫번째 원소의 주소값이 나옵니다.
    * 배열의 원소들도 포인터 연산을 통해 접근할 수 있습니다.

> 예  
```c
    int a[100] = {0};
    int *p = a;             // p = &a[0]

    printf(" p의 값은 %d\n" , *p);

    p = a + 1;              // p[1] 접근
    *p = 10;                
    *(a+2) = 20;            // 배열 이름으로도 포인터 연산 가능합니다.
    *(p + 2) = 30;          // p[1 + 2] 즉 p[3]에 접근합니다.

    printf(" p[1] = %d, p[2] = %d, p[3] = %d", p[1], p[2], p[3]);
```
---
**프로그램 결과**

    p의 값은 0
    p[1] = 10, p[2] = 20, p[3] = 30
---

## 2차원 배열과 포인터
2차원 배열의 인덱스를 하나 제거하면 포인터가 됩니다.

```c
int b[i][j]
b[a] == &b[a][0]
b[a]+c == &b[a][c]
```

2차원 배열의 인덱스를 두 개 제거하면 포인터가 됩니다.

```c
int b[i][j]
b == b[j] 크기의 배열을 가르키는 포인터 
b + a == &b[a][0]
```

포인터를 이용한 b[a][c]의 표기 방법
```c
*(b[a] + c)
*(*(b + a) + c)
(*(b + a))[c]
```

## 배열 포인터 
배열 포인터란 배열을 가리킬 수 있는 포인터를 의미합니다.

> 배열 포인터 예
```c
int main{
int arr[2][3] = {{10, 20, 30},{40, 50, 60}}; 
int (*pArr)[3] = arr;

printf("%d\n", arr[1][1]);  
printf("%d\n", pArr[1][1]);
return 0; 
}
```
---
**프로그램 결과**

    50 50 
---



## 포인터 배열
포인터 배열이란 배열 요소로 포인터 변수를 가지는 배열을 의미합니다.

> 포인터 배열 예
```c
int a = 1, b = 2, c = 3;
int* arr[3] = {&a, &b, &c}; 
 
for (int i = 0; i < arr_len; i++){
    printf("%d  ", *arr[i]);
}  
```
---
**프로그램 결과**

    1 2 3 
---

## 문자열과 포인터
문자열 배열은 큰 따옴표를 통해 문자열을 넣을 수 있습니다.

문자열 배열은 문자열을 변경할 수 없어서 문자열 상수라고도 합니다.

```
char str[] = "C Github"
```

문자열 포인터는 문자열을 변경할 수 있습니다.

```c
char *p = "C Github"
*p = 'D'
printf("%s", p);
```

---
**프로그램 결과**

    D Github
---

* 주의 

C++ 11 이후에는 char * 에 문자열 상수를 바로 넣는 게 권장되지 않습니다.  
위의 프로그램처럼 문자를 바꾸지 않는다면 앞에 const를 추가한 const char * 을 사용해 주세요.




## 동적 메모리 할당
배열이나 문자열을 사용할 때 메모리를 다 쓰지 못하고 남는 경우가 있습니다.  
이러한 경우 메모리를 효율적으로 쓰기 위해 동적으로 메모리를 할당합니다.

* 동적 메모리 할당 방법
```c
calloc(데이터 개수, 자료형 크기)
malloc(바이트 크기)

// 사용 이후
free()
```

**프로그램**
```c
int(*p)[N], *q; // p : 2차원 배열을 포인트하기 위해

p = (int (*)[N])calloc(N * N, sizeof(int));
q = (int *) p;
for (i= 0; i< N * N; i++)
	q[i] = i;
for (i= 0; i< N; i++){
	for (j = 0; j < N; j++)
		printf("%3d ", p[i][j]);
	putchar('\n');
}

```

